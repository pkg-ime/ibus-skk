/* preferences.c generated by valac 0.14.0, the Vala compiler
 * generated from preferences.vala, do not modify */

/* 
 * Copyright (C) 2011 Daiki Ueno <ueno@unixuser.org>
 * Copyright (C) 2011 Red Hat, Inc.
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

#include <glib.h>
#include <glib-object.h>
#include <ibus.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <libskk/libskk.h>


#define TYPE_PREFERENCES (preferences_get_type ())
#define PREFERENCES(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PREFERENCES, Preferences))
#define PREFERENCES_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PREFERENCES, PreferencesClass))
#define IS_PREFERENCES(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PREFERENCES))
#define IS_PREFERENCES_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PREFERENCES))
#define PREFERENCES_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PREFERENCES, PreferencesClass))

typedef struct _Preferences Preferences;
typedef struct _PreferencesClass PreferencesClass;
typedef struct _PreferencesPrivate PreferencesPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_variant_iter_free0(var) ((var == NULL) ? NULL : (var = (g_variant_iter_free (var), NULL)))

struct _Preferences {
	GObject parent_instance;
	PreferencesPrivate * priv;
};

struct _PreferencesClass {
	GObjectClass parent_class;
};

struct _PreferencesPrivate {
	IBusConfig* config;
	GeeMap* _default;
	GeeMap* current;
};


static gpointer preferences_parent_class = NULL;

GType preferences_get_type (void) G_GNUC_CONST;
#define PREFERENCES_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PREFERENCES, PreferencesPrivate))
enum  {
	PREFERENCES_DUMMY_PROPERTY
};
void preferences_load (Preferences* self);
void preferences_save (Preferences* self);
GVariant* preferences_get (Preferences* self, const gchar* name);
void preferences_set (Preferences* self, const gchar* name, GVariant* value);
Preferences* preferences_new (IBusConfig* config);
Preferences* preferences_construct (GType object_type, IBusConfig* config);
static void preferences_value_changed_cb (Preferences* self, IBusConfig* config, const gchar* section, const gchar* name, GVariant* value);
static void _preferences_value_changed_cb_ibus_config_value_changed (IBusConfig* _sender, const gchar* p0, const gchar* p1, GVariant* p2, gpointer self);
static void g_cclosure_user_marshal_VOID__STRING_VARIANT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void preferences_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);

static const gchar* PREFERENCES_AUTO_START_HENKAN_KEYWORDS[28] = {"を", "、", "。", "．", "，", "？", "」", "！", "；", "：", ")", ";", ":", "）", "”", "】", "』", "》", "〉", "｝", "］", "〕", "}", "]", "?", ".", ",", "!"};

static gpointer _g_variant_ref0 (gpointer self) {
	return self ? g_variant_ref (self) : NULL;
}


void preferences_load (Preferences* self) {
	IBusConfig* _tmp0_;
	GVariant* _tmp1_ = NULL;
	GVariant* _tmp2_;
	GVariant* values;
	GVariant* _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->config;
	_tmp1_ = ibus_config_get_values (_tmp0_, "engine/skk");
	_tmp2_ = _g_variant_ref0 (_tmp1_);
	values = _tmp2_;
	_tmp3_ = values;
	if (_tmp3_ != NULL) {
		GVariant* _tmp4_;
		GVariantIter* _tmp5_ = NULL;
		GVariantIter* iter;
		GVariant* entry;
		_tmp4_ = values;
		_tmp5_ = g_variant_iter_new (_tmp4_);
		iter = _tmp5_;
		entry = NULL;
		while (TRUE) {
			GVariantIter* _tmp6_;
			GVariant* _tmp7_ = NULL;
			GVariant* _tmp8_;
			gchar* name = NULL;
			GVariant* value = NULL;
			GVariant* _tmp9_;
			GeeMap* _tmp10_;
			const gchar* _tmp11_;
			GVariant* _tmp12_;
			_tmp6_ = iter;
			_tmp7_ = g_variant_iter_next_value (_tmp6_);
			_g_variant_unref0 (entry);
			entry = _tmp7_;
			_tmp8_ = entry;
			if (!(_tmp8_ != NULL)) {
				break;
			}
			_tmp9_ = entry;
			g_variant_get (_tmp9_, "{sv}", &name, &value, NULL);
			_tmp10_ = self->priv->current;
			_tmp11_ = name;
			_tmp12_ = value;
			gee_map_set (_tmp10_, _tmp11_, _tmp12_);
			_g_variant_unref0 (value);
			_g_free0 (name);
		}
		_g_variant_unref0 (entry);
		_g_variant_iter_free0 (iter);
	}
	_g_variant_unref0 (values);
}


void preferences_save (Preferences* self) {
	GeeMap* _tmp0_;
	GeeMapIterator* _tmp1_ = NULL;
	GeeMapIterator* iter;
	GeeMapIterator* _tmp2_;
	gboolean _tmp3_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->current;
	_tmp1_ = gee_map_map_iterator (_tmp0_);
	iter = _tmp1_;
	_tmp2_ = iter;
	_tmp3_ = gee_map_iterator_first (_tmp2_);
	if (_tmp3_) {
		{
			gboolean _tmp4_;
			_tmp4_ = TRUE;
			while (TRUE) {
				gboolean _tmp5_;
				IBusConfig* _tmp8_;
				GeeMapIterator* _tmp9_;
				gpointer _tmp10_ = NULL;
				gchar* _tmp11_;
				GeeMapIterator* _tmp12_;
				gpointer _tmp13_ = NULL;
				GVariant* _tmp14_;
				_tmp5_ = _tmp4_;
				if (!_tmp5_) {
					GeeMapIterator* _tmp6_;
					gboolean _tmp7_ = FALSE;
					_tmp6_ = iter;
					_tmp7_ = gee_map_iterator_next (_tmp6_);
					if (!_tmp7_) {
						break;
					}
				}
				_tmp4_ = FALSE;
				_tmp8_ = self->priv->config;
				_tmp9_ = iter;
				_tmp10_ = gee_map_iterator_get_key (_tmp9_);
				_tmp11_ = (gchar*) _tmp10_;
				_tmp12_ = iter;
				_tmp13_ = gee_map_iterator_get_value (_tmp12_);
				_tmp14_ = (GVariant*) _tmp13_;
				ibus_config_set_value (_tmp8_, "engine/skk", _tmp11_, _tmp14_);
				_g_variant_unref0 (_tmp14_);
				_g_free0 (_tmp11_);
			}
		}
	}
	_g_object_unref0 (iter);
}


GVariant* preferences_get (Preferences* self, const gchar* name) {
	GVariant* result = NULL;
	GeeMap* _tmp0_;
	const gchar* _tmp1_;
	gpointer _tmp2_ = NULL;
	GVariant* value;
	GVariant* _tmp3_;
	GeeMap* _tmp4_;
	const gchar* _tmp5_;
	gpointer _tmp6_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (name != NULL, NULL);
	_tmp0_ = self->priv->current;
	_tmp1_ = name;
	_tmp2_ = gee_map_get (_tmp0_, _tmp1_);
	value = (GVariant*) _tmp2_;
	_tmp3_ = value;
	if (_tmp3_ != NULL) {
		result = value;
		return result;
	}
	_tmp4_ = self->priv->_default;
	_tmp5_ = name;
	_tmp6_ = gee_map_get (_tmp4_, _tmp5_);
	result = (GVariant*) _tmp6_;
	_g_variant_unref0 (value);
	return result;
}


void preferences_set (Preferences* self, const gchar* name, GVariant* value) {
	GeeMap* _tmp0_;
	const gchar* _tmp1_;
	GVariant* _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (name != NULL);
	g_return_if_fail (value != NULL);
	_tmp0_ = self->priv->current;
	_tmp1_ = name;
	_tmp2_ = value;
	gee_map_set (_tmp0_, _tmp1_, _tmp2_);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _preferences_value_changed_cb_ibus_config_value_changed (IBusConfig* _sender, const gchar* p0, const gchar* p1, GVariant* p2, gpointer self) {
	preferences_value_changed_cb (self, _sender, p0, p1, p2);
}


Preferences* preferences_construct (GType object_type, IBusConfig* config) {
	Preferences * self = NULL;
	GeeArrayList* _tmp0_;
	GeeArrayList* dictionaries;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	GeeMap* _tmp4_;
	gint _tmp5_ = 0;
	gpointer* _tmp6_ = NULL;
	gchar** _tmp7_;
	gint _tmp7__length1;
	GVariant* _tmp8_;
	GVariant* _tmp9_;
	GeeMap* _tmp10_;
	GVariant* _tmp11_;
	GVariant* _tmp12_;
	GeeMap* _tmp13_;
	GVariant* _tmp14_;
	GVariant* _tmp15_;
	GeeMap* _tmp16_;
	GVariant* _tmp17_;
	GVariant* _tmp18_;
	GeeMap* _tmp19_;
	GVariant* _tmp20_;
	GVariant* _tmp21_;
	GeeMap* _tmp22_;
	GVariant* _tmp23_;
	GVariant* _tmp24_;
	GeeMap* _tmp25_;
	GVariant* _tmp26_;
	GVariant* _tmp27_;
	GeeMap* _tmp28_;
	GVariant* _tmp29_;
	GVariant* _tmp30_;
	GeeMap* _tmp31_;
	GVariant* _tmp32_;
	GVariant* _tmp33_;
	IBusConfig* _tmp34_;
	IBusConfig* _tmp35_;
	IBusConfig* _tmp36_;
	g_return_val_if_fail (config != NULL, NULL);
	self = (Preferences*) g_object_new (object_type, NULL);
	_tmp0_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL);
	dictionaries = _tmp0_;
	_tmp1_ = g_get_user_config_dir ();
	_tmp2_ = g_strdup_printf ("type=file,file=%s/ibus-skk/user.dict,mode=readwrite", _tmp1_);
	_tmp3_ = _tmp2_;
	gee_abstract_collection_add ((GeeAbstractCollection*) dictionaries, _tmp3_);
	_g_free0 (_tmp3_);
	gee_abstract_collection_add ((GeeAbstractCollection*) dictionaries, "type=file,file=/usr/share/skk/SKK-JISYO.L,mode=readonly");
	gee_abstract_collection_add ((GeeAbstractCollection*) dictionaries, "type=server,host=localhost,port=1178");
	_tmp4_ = self->priv->_default;
	_tmp6_ = gee_abstract_collection_to_array ((GeeAbstractCollection*) dictionaries, &_tmp5_);
	_tmp7_ = _tmp6_;
	_tmp7__length1 = _tmp5_;
	_tmp8_ = g_variant_new_strv (_tmp7_, _tmp5_);
	_tmp9_ = g_variant_ref_sink (_tmp8_);
	gee_map_set (_tmp4_, "dictionaries", _tmp9_);
	_g_variant_unref0 (_tmp9_);
	_tmp7_ = (_vala_array_free (_tmp7_, _tmp7__length1, (GDestroyNotify) g_free), NULL);
	_tmp10_ = self->priv->_default;
	_tmp11_ = g_variant_new_strv (PREFERENCES_AUTO_START_HENKAN_KEYWORDS, G_N_ELEMENTS (PREFERENCES_AUTO_START_HENKAN_KEYWORDS));
	_tmp12_ = g_variant_ref_sink (_tmp11_);
	gee_map_set (_tmp10_, "auto_start_henkan_keywords", _tmp12_);
	_g_variant_unref0 (_tmp12_);
	_tmp13_ = self->priv->_default;
	_tmp14_ = g_variant_new_int32 ((gint32) SKK_PERIOD_STYLE_JA_JA);
	_tmp15_ = g_variant_ref_sink (_tmp14_);
	gee_map_set (_tmp13_, "period_style", _tmp15_);
	_g_variant_unref0 (_tmp15_);
	_tmp16_ = self->priv->_default;
	_tmp17_ = g_variant_new_int32 ((gint32) 7);
	_tmp18_ = g_variant_ref_sink (_tmp17_);
	gee_map_set (_tmp16_, "page_size", _tmp18_);
	_g_variant_unref0 (_tmp18_);
	_tmp19_ = self->priv->_default;
	_tmp20_ = g_variant_new_int32 ((gint32) 4);
	_tmp21_ = g_variant_ref_sink (_tmp20_);
	gee_map_set (_tmp19_, "pagination_start", _tmp21_);
	_g_variant_unref0 (_tmp21_);
	_tmp22_ = self->priv->_default;
	_tmp23_ = g_variant_new_boolean (TRUE);
	_tmp24_ = g_variant_ref_sink (_tmp23_);
	gee_map_set (_tmp22_, "show_annotation", _tmp24_);
	_g_variant_unref0 (_tmp24_);
	_tmp25_ = self->priv->_default;
	_tmp26_ = g_variant_new_int32 ((gint32) SKK_INPUT_MODE_HIRAGANA);
	_tmp27_ = g_variant_ref_sink (_tmp26_);
	gee_map_set (_tmp25_, "initial_input_mode", _tmp27_);
	_g_variant_unref0 (_tmp27_);
	_tmp28_ = self->priv->_default;
	_tmp29_ = g_variant_new_boolean (FALSE);
	_tmp30_ = g_variant_ref_sink (_tmp29_);
	gee_map_set (_tmp28_, "egg_like_newline", _tmp30_);
	_g_variant_unref0 (_tmp30_);
	_tmp31_ = self->priv->_default;
	_tmp32_ = g_variant_new_string ("default");
	_tmp33_ = g_variant_ref_sink (_tmp32_);
	gee_map_set (_tmp31_, "typing_rule", _tmp33_);
	_g_variant_unref0 (_tmp33_);
	_tmp34_ = config;
	_tmp35_ = _g_object_ref0 (_tmp34_);
	_g_object_unref0 (self->priv->config);
	self->priv->config = _tmp35_;
	preferences_load (self);
	_tmp36_ = config;
	g_signal_connect_object (_tmp36_, "value-changed", (GCallback) _preferences_value_changed_cb_ibus_config_value_changed, self, 0);
	_g_object_unref0 (dictionaries);
	return self;
}


Preferences* preferences_new (IBusConfig* config) {
	return preferences_construct (TYPE_PREFERENCES, config);
}


static void preferences_value_changed_cb (Preferences* self, IBusConfig* config, const gchar* section, const gchar* name, GVariant* value) {
	const gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (config != NULL);
	g_return_if_fail (section != NULL);
	g_return_if_fail (name != NULL);
	g_return_if_fail (value != NULL);
	_tmp0_ = section;
	if (g_strcmp0 (_tmp0_, "engine/skk") == 0) {
		GeeMap* _tmp1_;
		const gchar* _tmp2_;
		GVariant* _tmp3_;
		const gchar* _tmp4_;
		GVariant* _tmp5_;
		_tmp1_ = self->priv->current;
		_tmp2_ = name;
		_tmp3_ = value;
		gee_map_set (_tmp1_, _tmp2_, _tmp3_);
		_tmp4_ = name;
		_tmp5_ = value;
		g_signal_emit_by_name (self, "value-changed", _tmp4_, _tmp5_);
	}
}


static void g_cclosure_user_marshal_VOID__STRING_VARIANT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__STRING_VARIANT) (gpointer data1, const char* arg_1, gpointer arg_2, gpointer data2);
	register GMarshalFunc_VOID__STRING_VARIANT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_VARIANT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_variant (param_values + 2), data2);
}


static void preferences_class_init (PreferencesClass * klass) {
	preferences_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (PreferencesPrivate));
	G_OBJECT_CLASS (klass)->finalize = preferences_finalize;
	g_signal_new ("value_changed", TYPE_PREFERENCES, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_VARIANT, G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_VARIANT);
}


static void preferences_instance_init (Preferences * self) {
	GeeHashMap* _tmp0_;
	GeeHashMap* _tmp1_;
	self->priv = PREFERENCES_GET_PRIVATE (self);
	_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_VARIANT, (GBoxedCopyFunc) g_variant_ref, g_variant_unref, NULL, NULL, NULL);
	self->priv->_default = (GeeMap*) _tmp0_;
	_tmp1_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_VARIANT, (GBoxedCopyFunc) g_variant_ref, g_variant_unref, NULL, NULL, NULL);
	self->priv->current = (GeeMap*) _tmp1_;
}


static void preferences_finalize (GObject* obj) {
	Preferences * self;
	self = PREFERENCES (obj);
	_g_object_unref0 (self->priv->config);
	_g_object_unref0 (self->priv->_default);
	_g_object_unref0 (self->priv->current);
	G_OBJECT_CLASS (preferences_parent_class)->finalize (obj);
}


GType preferences_get_type (void) {
	static volatile gsize preferences_type_id__volatile = 0;
	if (g_once_init_enter (&preferences_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (PreferencesClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) preferences_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Preferences), 0, (GInstanceInitFunc) preferences_instance_init, NULL };
		GType preferences_type_id;
		preferences_type_id = g_type_register_static (G_TYPE_OBJECT, "Preferences", &g_define_type_info, 0);
		g_once_init_leave (&preferences_type_id__volatile, preferences_type_id);
	}
	return preferences_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



